---
title: "Adquisición de un monitor de PC mediante métodos multicriterio"
author: "Víctor Silva Nieves"
format: 
  html:
    toc: false
    number-sections: false
    code-fold: false
    embed-resources: true
    theme:
      - cosmo
      - estilo/tema.scss
    warning: false
lang: es
---

# Presentación del problema

El objetivo de este documento será elegir la mejor alternativa a la hora de adquirir un nuevo monitor de PC. Se va a considerar que el individuo interesado en esta adquisición es un arquitecto que necesita un nuevo monitor para su estudio.

Se van a seleccionar 5 monitores diferentes, que tratan de representar una variedad de opciones en el mercado actual. Los criterios que se van a considerar son los siguientes:

* Precio (€)
* Tamaño (pulgadas)
* Frecuencia de actualización (Hz) o de refresco.
* Resolución (px)
* Consumo energético (W) en un instante.
* Densidad de píxeles (ppi)
* Brillo (nits)
* Contraste (en millones de colores M)

```{r}

# Carga de librerías necesarias
library(DiagrammeR)
library(kableExtra)
library(ahp)

# Carga de funciones multicriterio
source("funciones_clase/teoriadecision_funciones_multicriterio.R")
source("funciones_clase/teoriadecision_funciones_multicriterio_diagram.R")
source("funciones_clase/teoriadecision_funciones_multicriterio_utiles.R")

# Carga otras funciones
source("funciones_propias/otras_funciones.R")
source("funciones_propias/tablas_planteamiento_AHP.R")
source("funciones_propias/animación_grafo.R")

```

Y las alternativas, con sus correspondientes características, las podemos ver en la siguiente tabla:

```{r}
datos <- read.csv2("datos/monitores.csv", header = FALSE, sep = ";")
colnames(datos) <- c("Modelo","Precio", "Tamaño", "Frecuencia", "Resolución", "Consumo", "Densidad", "Brillo", "Colores")

crea_tabla_estilo(datos, nombresfila = FALSE)

ruta_imagenes <- c("datos/monitores/a1.png",
                   "datos/monitores/a2.png",
                   "datos/monitores/a3.png",
                   "datos/monitores/a4.png",
                   "datos/monitores/a5.png")

data.frame(Modelo = datos[1],
           Imágen = rep("", 5),
           check.names = FALSE) |> 
    kbl(booktabs = T, align = "c") |> 
    kable_paper(full_width = T) |> 
    column_spec(2, image = spec_image(ruta_imagenes, 280, 200)) |> 
    row_spec(0, bold = TRUE, background = "#F8A29E")
```

Este arquitecto busca un monitor que le permita trabajar con planos y renderizados de alta calidad. El precio le preocupa en poca medida, pero quiere un monitor que ofrezca buena resolución y una buena representación de colores. Además, valora un tamaño grande para facilitar su trabajo. En cuanto al consumo, quiere que sea lo más bajo posible, pero no lo valora especialmente.

# Elegir un método {#cambioMétodo}

::: {.panel-tabset} 

# Método AHP 

## Planteamiento para el método AHP

### Introducción

Para el método AHP, se va a dar una estructura jerárquica de criterios y subcriterios. Se van a considerar tres criterios: Coste, calidad de imagen y experiencia de usuario.

* El criterio coste, incluye los subcriterios: precio y consumo energético.

* El criterio calidad de imagen, incluye los subcriterios: resolución, densidad, brillo y colores.

* El criterio experiencia de usuario, incluye los subcriterios: tamaño y frecuencia de actualización.

Vemos a continuación un diagrama que representa esta jerarquía:

```{r}
DiagrammeR::grViz("
digraph {
    node [shape = rectangle, style = 'rounded,filled', fontname = 'Source Sans Pro', fontsize = '12']
    A [label = 'Elección de un monitor', fillcolor = '#C7645D']
    B [label = 'Coste', fillcolor = '#E2807A']
    C [label = 'Calidad de Imagen', fillcolor = '#E2807A']
    D [label = 'Experiencia de Usuario', fillcolor = '#E2807A']
    E [label = 'Precio', fillcolor = '#F8A29E']
    F [label = 'Consumo', fillcolor = '#F8A29E']
    G [label = 'Resolución', fillcolor = '#F8A29E']
    H [label = 'Densidad', fillcolor = '#F8A29E']
    I [label = 'Brillo', fillcolor = '#F8A29E']
    J [label = 'Colores', fillcolor = '#F8A29E']
    K [label = 'Tamaño', fillcolor = '#F8A29E']
    L [label = 'Frecuencia', fillcolor = '#F8A29E']
    edge[color = '#005A89', arrowsize = '0.5']
    A -> {B C D}
    B -> {E F}
    C -> {G H I J}
    D -> {K L}
}")
```

### Matrices de comparación por parejas

A continuación se establecen las siguientes matrices de comparación por parejas para los criterios, subcriterios y alternativas. Se ha realizado en un script anexo llamado "tablas_planteamiento_AHP.R" para una mejor legibilidad.

#### Nivel 1 - Criterios

En cuanto a los criterios, atendiendo a las indicaciones dadas por el arquitecto, se ha establecido la siquiente matriz de comparaciones dos a dos. 

`{r} tbahp0101`

Se ha valorado la calidad de imagen como de importancia muy fuerte sobre el precio y moderada sobre la experiencia de usuario, además de importancia fuerte de la experiencia de usuario sobre el precio. De esta forma relegamos el precio como criterio de menor importancia, lejos de la calidad de imagen (en primer lugar) y de la experiencia de usuario (segundo lugar).

#### Nivel 2 - Subcriterios:

##### **Coste:**
Los subcriterios dentro del coste eran precio y consumo, vemos su comparación dos a dos en esta tabla.

`{r} tbahp0201`

Se considera que el precio es fuertemente más relevante que el consumo, pues el arquitecto tendría que pasar muchos años sin renovar este monitor para que el consumo tenga incidencia real en el coste del monitor.

##### **Calidad de Imagen:**
Los subcriterios que conforman la calidad de imagen son comparados dos a dos en la siguiente tabla.

`{r} tbahp0202`

La resolución y la densidad son dos parámetros prácticamente de igual importancia, definen la calidad de un monitor conjuntamente, pero queremos que la resolución tenga una incidencia levemente superior en el resultado final. Por ello ambos subcriterios son más fuertes en relevancia que los otros dos, ajustándose los valores sobre los otros criterios a esta sutil diferencia entre resolución y densidad de píxeles. Por su parte, la cantidad de colores será algo más relevante que el brillo y le hemos dado una imporancia moderada sobre este.

##### **Experiencia de Usuario:**

La siguiente tabla muestra los subcriterios de la experiencia de usuario, tamaño y frecuencia de actualización.

`{r} tbahp0203`

La importancia del tamaño sobre la frecuencia de actualización es moderada, el arquitecto pasa muchas horas delante del ordenador y la necesidad de una buena frecuencia, que ayude a un menor cansancio visual, es de casi la misma relevancia que un buen tamaño para el trabajo multitarea.

#### Nivel 3 - Alternativas:

A continuación, se comparan las alternativas para todos los subcriterios. Se añade un pequeño comentario acerca del criterio seguido.

##### **Precio:**

Se ha intentado dar la relevancia de los precios acorde a las diferencias de precio entre los monitores, de esta forma las alternativas más caras tienen relevancia casi idéntica entre si, la opción más económica oscila entre preferencias fuertes y extremas con el resto de monitores. Y las opciones intermedias oscilan entre preferencias moderadas y muy fuertes sobre las alternativas más caras.

`{r} tbahp0301`

##### **Consumo:**

En cuanto al consumo, una opción destaca sobre las demás. Con 21W frente a 35W de la siguiente alternativa en menor consumo. Por ello su preferencia va desde muy fuerte hasta extrema sobre el resto de opciones. El resto de alternativas con consumos muy similares tienen preferencias entre muy moderadas y casi fuertes.

`{r} tbahp0302`

##### **Resolución:**

En la resolución tenemos 3 grupos, y todas las preferencias son las mismas para las alternativas en cada grupo. Las de resolución más alta tienen preferencia extrema sobre la de resolución más baja y fuerte sobre las de resolución media. Mientras, las de resolución media tienen preferencia moderada sobre las de resolución baja.

`{r} tbahp0303`

##### **Densidad:**

Para la densidad se ha intentado asignar la preferencia según los ppi de cada monitor, cuanto mayor es esta cifra sobre la de la alternativa a comparar, más fuerte será la preferencia sobre ella.

`{r} tbahp0304`

##### **Brillo:**

Para el brillo se ha optado por un criterio similar al de la resolución.

`{r} tbahp0305`

##### **Colores:**

En cuanto a la comparación dos a dos de la cantidad de colores (millones), se han hecho dos grupos. Los que tienen +1000 colores y los que tienen 16.7, así los del primer grupo tendrán una preferencia muy fuerte sobre los del segundo.

`{r} tbahp0306`

##### **Tamaño:**

Criterio similar al de la resolución, pantallas en torno a las 40" preferencias muy fuertes sobre las de 27" y fuertes sobre la de 31.5". Pantalla de 31.5" preferencia moderada sobre las de 27".

`{r} tbahp0307`

##### **Frecuencia:**

Criterio similar al del precio, dando la preferencia según el valor de la frecuencia de cada monitor.

`{r} tbahp0308`

## Desarrollo del problema {#cambioAHP}

::: {.panel-tabset}

## AHP con R

# AHP con R

### Introducción de las matrices en R

En primer lugar vamos a introducir las matrices de comparación por parejas para emplear las funciones de clase. Se ha utilizado además la función `multicriterio.metodoAHP.chequeo.matrizcomparaciones` para asegurar que las matrices son válidas.

```{r}

## CRITERIOS

matriz_criterios_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(1/7,1/5,3), numalternativas = 3, v.nombres.alternativas = c(
        "Coste", "Calidad de Imagen", "Experiencia de Usuario"))

## SUBCRITERIOS

#Coste
matriz_subcriterio_coste_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(5), numalternativas = 2, v.nombres.alternativas = c("Precio", "Consumo"))

#Calidad de imagen
matriz_subcriterio_calidad_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(2,7,5,5,3,1/3), numalternativas = 4, v.nombres.alternativas = c(
        "Resolución", "Densidad", "Brillo", "Colores"))

#Experiencia de usuario
matriz_subcriterio_experiencia_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(3), numalternativas = 2, v.nombres.alternativas = c("Tamaño", "Frecuencia"))

## ALTERNATIVAS
 
#Precio
matriz_alternativas_precio_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(1/7,1/2,1/9,1/5,5,1/4,3,1/7,1/4,5), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Consumo
matriz_alternativas_consumo_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(1/4,1/2,1/9,1/3,3,1/6,2,1/8,3,7), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Resolución
matriz_alternativas_resolucion_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(5,5,9,1,1,3,1/5,3,1/5,1/9), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Densidad
matriz_alternativas_densidad_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(3,5,7,1,3,5,1/3,3,1/5,1/7), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Brillo
matriz_alternativas_brillo_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(7,2,7,6,1/3,1,2,6,5,2), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Colores
matriz_alternativas_colores_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(7,1,7,1,1/7,1,1/7,7,1,1/7), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Tamaño
matriz_alternativas_tamaño_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(7,1,7,5,1/7,1,1/3,7,5,1/3), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

# Frecuencia
matriz_alternativas_frecuencia_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(1/5,1/3,5,7,3,7,9,6,8,3), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

```

```{r}
## Intento trabajar con listas para reducir el código

lista_matrices_parejas <- list(matriz_criterios_ahp,
                               matriz_subcriterio_coste_ahp,
                               matriz_subcriterio_calidad_ahp,
                               matriz_subcriterio_experiencia_ahp,
                               matriz_alternativas_precio_ahp,
                               matriz_alternativas_consumo_ahp,
                               matriz_alternativas_resolucion_ahp,
                               matriz_alternativas_densidad_ahp,
                               matriz_alternativas_brillo_ahp,
                               matriz_alternativas_colores_ahp,
                               matriz_alternativas_tamaño_ahp,
                               matriz_alternativas_frecuencia_ahp)

## Le ponemos nombres para facilitar su localización
nombres_matrices <- c("Criterios", "Coste", "Calidad", "Experiencia",
                                "Precio", "Consumo", "Resolución", "Densidad",
                                "Brillo", "Colores", "Tamaño", "Frecuencia")
names(lista_matrices_parejas) <- nombres_matrices

## Ahora a todas las matrices de esta lista le aplicamos la función de inconsistencia

lista_inconsistencias <- lapply(lista_matrices_parejas, multicriterio.metodoAHP.coef.inconsistencia)

## Ahora a todas las matrices de la lista de matrices por parejas le aplicamos la función para calcular pesos

lista_pesos <- lapply(lista_matrices_parejas, multicriterio.metodoAHP.variante2.mediageometrica)

```

### Inconsistencia

Se ha realizado una tabla que recoge el análisis de inconsistencia de todas las matrices empleadas en el método AHP. Además se incluye una columna que recoge la validación de la matriz para su uso en el método AHP.

```{r}
## Al usar el método con listas, la hemos calculado también para matrices 2x2 sin ser necesario. 
# Esta función, permite redondear RI de aquellos que queremos calcular y sustituye NaN por "-"
# para mostrarlo en la tabla.

convertir_vector_valores_listaNaN <- function (x) {
    if(is.nan(x$RI.coef.inconsistencia)){
        inter <- "-"
    } else {
        inter <- round(x$RI.coef.inconsistencia,4)
    }
    return(inter)
}
tabla_inconsistencia_ahp <- data.frame(
    Matriz = c(
        "Criterios",
        "Subcriterio Coste",
        "Subcriterio Calidad de Imagen",
        "Subcriterio Experiencia de Usuario",
        "Alternativa Precio",
        "Alternativa Consumo",
        "Alternativa Resolución",
        "Alternativa Densidad",
        "Alternativa Brillo",
        "Alternativa Colores",
        "Alternativa Tamaño",
        "Alternativa Frecuencia"
    ),
    `RI Coeficiente inconsistencia` = sapply(lista_inconsistencias, convertir_vector_valores_listaNaN),
    Estado = sapply(lista_inconsistencias, function(x) x$mensaje),
    `Matriz aceptable` = sapply(lista_matrices_parejas, multicriterio.metodoAHP.chequeo.matrizcomparaciones))

    crea_tabla_estilo(tabla_inconsistencia_ahp, nombresfila = FALSE)

```

<br>

Si alguna de las matrices de comparación hubiese dado un coeficiente de inconsistencia mayor a 0.1, tendríamos que haber revisado la matriz en cuestión para asegurarnos de que las relaciones lógicas entre las alternativas se han respetado. En nuestro caso, su realización ha sido meticulosa y la consistencia se ha podido cumplir sin rehacer las tablas.

### Cálculo de los pesos

#### **Criterios:**

En primer lugar vamos a calcular los pesos finales para el último nivel de criterios y subcriterios, para ello multiplicaremos la valoración de cada criterio por la valoración de cada uno de los subcriterios que lo componen.

```{r}
# Preparación matriz criterios*subcriterios

c11 <- lista_pesos$Criterios$valoraciones.ahp[1] * lista_pesos$Coste$valoraciones.ahp[1]
c12 <- lista_pesos$Criterios$valoraciones.ahp[1] * lista_pesos$Coste$valoraciones.ahp[2]
c21 <- lista_pesos$Criterios$valoraciones.ahp[2] * lista_pesos$Calidad$valoraciones.ahp[1]
c22 <- lista_pesos$Criterios$valoraciones.ahp[2] * lista_pesos$Calidad$valoraciones.ahp[2]
c23 <- lista_pesos$Criterios$valoraciones.ahp[2] * lista_pesos$Calidad$valoraciones.ahp[3]
c24 <- lista_pesos$Criterios$valoraciones.ahp[2] * lista_pesos$Calidad$valoraciones.ahp[4]
c31 <- lista_pesos$Criterios$valoraciones.ahp[3] * lista_pesos$Experiencia$valoraciones.ahp[1]
c32 <- lista_pesos$Criterios$valoraciones.ahp[3] * lista_pesos$Experiencia$valoraciones.ahp[2]

criterios_subcriterios <- c(c11,c12,c21,c22,c23,c24,c31,c32)
names(criterios_subcriterios) <- nombres_matrices[5:12]

```

Los podemos ver en la siguiente tabla.

```{r}

tabla_criterios_subcriterios <- crea_tabla_estilo(data.frame(
                    Criterios = names(criterios_subcriterios),
                    Peso = criterios_subcriterios
                    ), nombresfila = FALSE)
tabla_criterios_subcriterios

```

#### **Alternativas:**

Vamos ahora a calcular los pesos finales para cada alternativa, donde un mayor peso indicará preferencia sobre alternativas con menor ponderación final.
```{r}
mat_pesos_alternativas <- matrix(c(
                            sapply(lista_pesos[5:12],function(x) x$valoraciones.ahp)
                            ),
                            ncol = 5, nrow = 8, byrow = TRUE)

ponderaciones_final <- data.frame((criterios_subcriterios %*% mat_pesos_alternativas))
colnames(ponderaciones_final) <- datos$Modelo

```

También los mostramos en una tabla:

```{r}

tabla_ponderación_final <- crea_tabla_estilo(ponderaciones_final, nombresfila = FALSE)
tabla_ponderación_final

```

Además se adjunta un grafo, mostrando como evolucionan los pesos en la jerarquía. Los pesos para cada eje se encuentran a su derecha.

```{r}
DiagrammeR::grViz("
digraph {
    node [shape = rectangle, style = 'rounded,filled', fontname = 'sans-serif', fontsize = '12']
    A [label = 'Elección de un monitor', fillcolor = '#C7645D']
    B [label = 'Coste', fillcolor = '#E2807A']
    C [label = 'Calidad de Imagen', fillcolor = '#E2807A']
    D [label = 'Experiencia de Usuario', fillcolor = '#E2807A']
    E [label = 'Precio', fillcolor = '#F8A29E']
    F [label = 'Consumo', fillcolor = '#F8A29E']
    G [label = 'Resolución', fillcolor = '#F8A29E']
    H [label = 'Densidad', fillcolor = '#F8A29E']
    I [label = 'Brillo', fillcolor = '#F8A29E']
    J [label = 'Colores', fillcolor = '#F8A29E']
    K [label = 'Tamaño', fillcolor = '#F8A29E']
    L [label = 'Frecuencia', fillcolor = '#F8A29E']
    M [label = 'Alternativas', fillcolor = '#7FBFF5']
    N [label = 'LG UltraFine 40WT95UF', fillcolor = '#7FBFF5']
    O [label = 'Asus TUF Gaming VG27AQ3A', fillcolor = '#7FBFF5']
    P [label = 'MSI MAG401QR', fillcolor = '#7FBFF5']
    Q [label = 'Asus VZ27EHF', fillcolor = '#7FBFF5']
    R [label = 'Samsung UJ59', fillcolor = '#7FBFF5']
    edge[color = '#005A89', arrowsize = '0.5', fontname = 'sans-serif', fontsize = '10']
    A -> B [label = '  0.0719']
    A -> C [label = '  0.6491']
    A -> D [label = '  0.279']
    B -> E [label = '  0.833']
    B -> F [label = '  0.167']
    C -> G [label = '  0.523']
    C -> H [label = '  0.299']
    C -> I [label = '  0.057']
    C -> J [label = '  0.121']
    D -> K [label = '  0.75']
    D -> L [label = '  0.25']
    E -> M [label = '  0.06']
    F -> M [label = '  0.012']
    G -> M [label = '  0.34']
    H -> M [label = '  0.194']
    I -> M [label = '  0.037']
    J -> M [label = '  0.08']
    K -> M [label = '  0.209']
    L -> M [label = '  0.07']
    M -> N [label = '  0.343']
    M -> O [label = '  0.129']
    M -> P [label = '  0.186']
    M -> Q [label = '  0.079']
    M -> R [label = '  0.264']
}")

```

## AHP con paquete

# AHP con paquete

### Preparación del modelo

En primer lugar tenemos que crear el archivo ahp que almacena el modelo necesario para este paquete, se encuentra en la raíz del proyecto y lo cargamos con ayuda del paquete ahp. Además vamos a calcular las prioridades, pero no vamos a mostrar el modelo en el documento.

```{r}

modelo_ahp <- ahp::Load("modelo_monitores.ahp")
#Paso 2. Calcular las prioridades
Calculate(modelo_ahp)
# print(modelo_ahp, priority = function(x) x$parent$priority["Total", x$name])
```

### Jerarquía de los criterios

Para observar que el modelo se ha introducido correctamente, y para una mejor comprensión nos vamos a apoyar del siguiente grafo, que nos permite observar la jerarquía de los criterios, los subcriterios y las alternativas.

```{r}
#Paso 3. Visualizar la jerarquía
Visualize(modelo_ahp, 
          criteriaNodesStyle = list(
                                style = "filled, rounded",
                                penwidth = 3,
                                color = "#C3625B",
                                fillcolor = "#F8A29E" ,
                                shape = "box",
                                fontname = "sans-serif"), 
          alternativeNodesStyle = list(
                                style = "filled, rounded",
                                penwidth = 3,
                                color = "#005682",
                                fillcolor = "#7FBFF5" ,
                                shape = "box",
                                fontname = "sans-serif"))

```

### Análisis

En este último paso vamos a análizar el modelo, para ello vamos a mostrar en dos tablas los resultados para este modelo. También hay una opción en el paquete para mostrar este resultado sin tabla, se ha escogido la opción con tabla por facilitar su lectura e interpretación. Así no mostramos resultados repetidos.

```{r}
# Tabla "priority"
aa = AnalyzeTable(modelo_ahp,variable = "priority",sort = "orig", weightColor = "#F8A29E", consistencyColor = "#C6AA74", alternativeColor = "#7FBFF5")
formattable::as.htmlwidget(aa)
```


<br>

Esta primera tabla muestra en cada fila de los subcriterios el peso que tiene cada alternativa en ese subcriterio, facilita ver con claridad que alternativa se desempeña mejor en cada subcriterio.
En la columna "Priority" podemos ver el desglose de los pesos, primero como se reparte la prioridad total entre cada criterio (Coste un 7'2%, Calidad un 64'9% y Experiencia de usuario un 27'9%) y segundo el mismo reparto en cada subcriterio. Es decir, nos muestra el porcentaje de prioridad dentro de cada grupo. Además del cálculo de la inconsistencia en la última columna.


```{r}
#Tabla pesos
aa = AnalyzeTable(modelo_ahp, sort = "orig", weightColor = "#F8A29E", consistencyColor = "#C6AA74", alternativeColor = "#7FBFF5")
formattable::as.htmlwidget(aa)
```

<br>

En esta otra se ven los pesos para cada monitor (ponderaciones finales) en la primera fila, además la fila de cada criterio muestra cuanto del peso total viene dado por este criterio para cada alternativa, de forma que la suma de los porcentajes de cada alternativa en esos criterios es el peso asignado a cada alternativa, y de igual forma para los subcriterios. Así para la alternativa elegida: Peso a1 = 34,2%, Coste (0,3%) + Calidad (24,6%) + Experiencia (9,3%), análogo para los subcriterios, nos permite observar cuanto ha influido cada criterio/subcriterio para el peso final de las alternativas.
Esta tabla contiene los resultados que hemos obtenido con las funciones de clase la ya mencionada primera fila y en la columna "Weight" si nos fijamos en las filas de los subcriterios, encontramos los pesos que hemos obtenido para el último nivel de la jerarquía de criterios.


### Uso de la aplicación shiny
```{r}
#| eval: false
ahp::RunGUI()
```

Se adjuntan algunas capturas que se han realizado mientras se utilizaba la aplicación shiny para este problema. Los resultados son iguales a los obtenidos en el código aquí expuesto.

![Cargar el modelo](AHP-Shiny/Shiny1.png)
<br>

![Jerarquía](AHP-Shiny/Shiny2.png)
<br>

![Tablas resultado](AHP-Shiny/Shiny3.png)

:::

<div style="text-align: right;">
<a href="#cambioAHP" class="btn-custom">Cambiar desarrollo AHP</a>
</div>

## Conclusiones AHP

Podemos decir que obtenemos dos conclusiones principales tras el análisis de este problema multicriterio con AHP. Ambos métodos usados (funciones de clase y paquete ahp) deben ofrecer, y ofrecen, los mismos resultados.

La primera es relativa a los pesos que se han asignado a los criterios con los que empezábamos el problema (tras utilizar la jerarquía por niveles). Estos pesos serán válidos para otros métodos de decisión multicriterio y consideramos el método AHP como consistente a la hora de obtener pesos (también) para otros métodos.

La segunda es relativa a las ponderaciones finales de cada una de las alternativas, y esto se traduce en que la mejor alternativa es el modelo "LG Ultrafine 40WT95UF" con un peso del 34'28%. La que será nuestra decisión final. Además la segunda alternativa preferida sería el modelo "Samsung UJ59" con un peso del 26'41%. Esta información la emplearemos para comparar los métodos posteriormente.

# Método ELECTRE

## Planteamiento para el método ELECTRE

### Matriz de decisión

Se establece la matriz de decisión, tenemos que hacer negativos los valores que se van a minimizar. Esta matriz de decisión será empleada en los métodos posteriores.

```{r}

matriz_decisión <- multicriterio.crea.matrizdecision(
                    c(-505,-40,2160,139,450,1060,39.7,120,
                      -244,-35,1440,108,250,16.7,27,180,
                      -449,-39,1440,93,400,1070,40,155,
                      -108,-21,1080,81,250,16.7,27,100,
                      -290,-37,2160,139,270,1000,31.5,60
                    ), 
                    numalternativas = 5,
                    numcriterios = 8,
                    v.nombresalt = names(ponderaciones_final),
                    v.nombrescri = names(criterios_subcriterios)
)
```

### Parámetros para el método

#### Pesos

Como se ha mencionado anteriormente, vamos a emplear los pesos que hemos obtenido tras emplear el método AHP para los criterios y subcriterios.

`{r} tabla_criterios_subcriterios`

#### Test de concordancia

El test de concordancia requiere un valor $\alpha$ que al ser reducido permite que más alternativas dominen a otras. El valor de $\alpha$ inicial que vamos a tomar es 0.7.

#### Test de discordancia

Los valores para $d_i$ pueden condicionar el resultado, en nuestro caso tenemos pocas alternativas, de características y rangos de precio muy variadas. Que lo hacen muy sensible a estos valores.

* Brillo: Una diferencia mayor de 50 nits en el brillo será suficiente para no pasar el test de discordancia.
* Colores: Se considera que diferencias menores a 100 (millones de colores) son insuficientes para no pasar el test de discordancia.
* Tamaño de pantalla: Una diferencia mayor de 3" hará que no se supere el test de discordancia

A continuación se proponen otros posibles valores para ejemplos con mayor cantidad de alternativas o con modelos de una gama similar.

* Precio: 150€
* Consumo: 15W 
* Resolución: 720 px
* Densidad de píxeles: 40 ppi
* Frecuencia de refresco: 60 Hz 

Además se considera que estas cantidades deberían ser ajustadas e introducidas en el método acorde a los pesos y las magnitudes. Por ejemplo, si se hubiera dado mayor importancia al precio en los pesos podríamos introducirlo como elemento para no superar el test de discordancia.

Algunas de las cantidades propuestas, como la resolución, serían adecuadas para este problema. La no influencia en el resultado final ha desincentivado su inclusión.

## Desarrollo del método ELECTRE

### Primera iteración
```{r}

iteración1_ELECTRE <- multicriterio.metodoELECTRE_I(matriz_decisión, 
                                                    pesos.criterios = criterios_subcriterios,
                                                    nivel.concordancia.minimo.alpha = 0.7,
                                                    no.se.compensan = c(Inf,Inf,Inf,Inf,50,100,3,Inf),
                                                    que.alternativas = TRUE
)

alternativas_iteración1_ELECTRE <- iteración1_ELECTRE$nucleo_aprox
```

Visualizamos el núcleo aproximado del método

```{r}
crea_tabla_estilo(data.frame(Núcleo = alternativas_iteración1_ELECTRE))
```


Vamos a mostrar también una tabla en la que vemos la correspondencia entre número de alternativa y el modelo al que corresponde puesto que habrá algunos resultados que muestren este número.

```{r}
tabla_alternativas_nombre <- data.frame(Modelo = names(ponderaciones_final),
                                        `Alternativa número` = c(1:5),
                                        check.names = FALSE)
crea_tabla_estilo(tabla_alternativas_nombre, nombresfila = FALSE)
```

<br>

Y a continuación, el grafo.
```{r}
construir_grafo_animado(iteración1_ELECTRE$relacion.dominante, plantilla = "spring")
```

Vemos que para este valor de $\alpha$, las mejores alternativas son `{r} alternativas_iteración1_ELECTRE`. Observando el grafo, vemos que son las únicas alternativas que no son dominadas por otras, además podríamos concluir que la siguiente mejor opción es a5.

Vamos a reducir el valor de $\alpha$ y nos vamos a quedar con estas dos alternativas para la segunda iteración.

### Segunda iteración

Vamos a mostrar el núcleo y el grafo.

```{r}
iteración2_ELECTRE <- multicriterio.metodoELECTRE_I(matriz_decisión, 
                                                    pesos.criterios = criterios_subcriterios,
                                                    nivel.concordancia.minimo.alpha = 0.6,
                                                    no.se.compensan = c(Inf,Inf,Inf,Inf,50,100,3,Inf),
                                                    que.alternativas = c(1,3)
)

alternativas_iteración2_ELECTRE <- iteración2_ELECTRE$nucleo_aprox
crea_tabla_estilo(data.frame(Núcleo = alternativas_iteración2_ELECTRE))

construir_grafo(iteración2_ELECTRE$relacion.dominante, que.alternativas = c(1,3))

``` 

Se puede observar que para $\alpha$ = 0.6 no hay dominancia de ninguna de estas alternativas sobre la otra. Vamos a reducir su valor una vez más y volvemos a aplicar el método.

### Tercera iteración

Mostramos el núcleo y el grafo una vez más.
```{r}
iteración3_ELECTRE <- multicriterio.metodoELECTRE_I(matriz_decisión, 
                                                    pesos.criterios = criterios_subcriterios,
                                                    nivel.concordancia.minimo.alpha = 0.55,
                                                    no.se.compensan = c(Inf,Inf,Inf,Inf,50,100,3,Inf),
                                                    que.alternativas = c(1,3)
)

alternativas_iteración3_ELECTRE <- iteración3_ELECTRE$nucleo_aprox
crea_tabla_estilo(data.frame(Núcleo = alternativas_iteración3_ELECTRE))

construir_grafo(iteración3_ELECTRE$relacion.dominante, que.alternativas = c(1,3))
``` 

Con este valor de $\alpha$ podemos ver que la alternativa `{r} names(alternativas_iteración3_ELECTRE)` domina a la alternativa `{r} names(alternativas_iteración2_ELECTRE)[-1]`.

## Conclusiones del método ELECTRE

Hemos observado que la mejor alternativa es el monitor "`{r} names(ponderaciones_final)[1]`", siendo la segunda mejor alternativa el monitor "`{r} names(ponderaciones_final)[3]`". Este método no nos ha dejado la libertad que querríamos a la hora de comparar las alternativas, como se ha mencionado previamente. Y da como resultado que una alternativa con menos resolución que la máxima quede en tercera posición. Principalmente causado por no poder controlar que algunas características las podamos considerar iguales (por sus pequeñas diferencias) en el test de concordancia. Se recomienda al arquitecto optar por el modelo "`{r} names(ponderaciones_final)[1]`".

# Método PROMETHEE

## Planteamiento para el método PROMETHEE

### Pesos

Vamos a emplear los pesos calculados en AHP para el último nivel de la jerarquía de criterios y subcriterios.

`{r} tabla_criterios_subcriterios`

### Funciones de preferencia

Para cada criterio vamos a elegir una función de preferencia según la naturaleza de cada uno, tratando además que proporcionen mayor satisfacción a los requisitos del arquitecto. Recordemos los criterios:

* **Precio:** El precio no está entre los requisitos más importantes, pero queremos que tenga algo de indicencia en la decisión final, querríamos que para cantidades con diferencias pequeñas no exista preferencia alguna. Por ello vamos a tomar un valor de Q= 50€

* **Consumo:** El coste anual que supone una diferencia de 10W trabajando es de 2.4€; Cálculo: 10W = 0.01 kW, 6 horas al día todos los días, 0.01 kW x 6 x 365 = 21.90 kWh anuales. Con el precio medio actual 0.1090 €/kWh: 21.90 kWh x 0.1090 €/kWh = 2.3871€. Esto motiva que optemos por el Cuasi-Criterio. Con no preferencia en todas las diferencias menores que Q = 10W.

* **Resolución:** Aquí queremos que haya dominancia absoluta en aquellos valores que superen a otros por 720 px, de esta forma establecemos niveles bien diferenciados según la resolución. Preferencia lineal

* **Densidad:** Para la densidad de píxeles vamos a emplear el criterio usual, queremos que cualquier diferencia positiva resulte en preferencia absoluta. Si tuviéramos monitores con densidad de píxeles por encima de 150 elegiríamos un criterio que nos permitiera diferenciar que a partir de esa cantidad apenas existe diferencia.

* **Brillo:** Para el brillo vamos a optar por dar preferencia a monitores con más de 100 nits de diferencia. Preferencia lineal.

* **Colores:** En el caso de los colores vamos a tratar de diferenciar aquellos con 16.7 millones de colores de aquellos que tienen +1000 millones de colores. Así cuando la diferencia sea menor de 100 (M) diremos que no hay preferencia. Cuasi-criterio.

* **Tamaño:** En cuanto al tamaño, queremos que monitores de tamaños muy similares no tengan dominancia entre si y que cualquier salto de tamaño medio nos proporcione dominancia absoluta. Para ello P = 4" y Q = 2". Función elegida lineal con área de indiferencia.

* **Frecuencia:** La frecuencia de refresco sigue una escala particular, normalmente saltos de 30 Hz se hacen notar bastante hasta cierta cantidad de Hz que los saltos deben ser mayores para que se note. Como para el arquitecto es un factor secundario, vamos a tomar que diferencias menores a 20 Hz no supondrán preferencia de una alternativa sobre otra y que saltos de 59 Hz si harán que escojamos una alternativa con preferencia absoluta. Para los valores intermedios queremos un reparto suavizado, vamos a tomar S = 60 Hz

Creamos la matriz de preferencia con estos valores.

```{r}
tabla_preferencia <- matrix(c(2,50,0,0, 
                              2,10,0,0, 
                              3,0,720,0,
                              1,0,0,0,
                              3,0,100,0,
                              2,100,0,0,
                              5,2,4,0,
                              6,60,20,60),
                              ncol = 4, 
                              byrow = TRUE)
```

## PROMETHEE I

### Índices

Vamos a utilizar la función de clase para este método, después se van a analizar los resultados. En primer lugar vamos a mostrar la tabla de índices, esta tabla nos indica en que grado se prefiere una alternativa frente a la otra por filas. Cuanto más cercano sea este valor a uno más fuerte será la preferencia global de la alternativa en la fila frente a la alternativa en la columna. 

```{r}
resultado_Promethee_I <- multicriterio.metodo.promethee_i_med(matriz_decisión,
                                                        criterios_subcriterios,
                                                        tabla_preferencia)

data.frame(resultado_Promethee_I$tabla.indices,
           check.names = FALSE) |> crea_tabla_estilo_comparación()
```

### Flujos entrante y saliente

Vamos a mostrar una tabla que recoge los valores para el flujo entrante y saliente de cada alternativa, se emplean para crear el orden parcial de las alternativas. Los casos en los que una alternativa supera a otra para estos flujos se ha visto en clase. En el siguiente apartado mostramos una tabla que usando estos valores nos indica la dominancia.

```{r}
tabla_flujos <- data.frame(Alternativa = names(ponderaciones_final),
                           `Flujo entrante` = resultado_Promethee_I$vflujos.ent,
                           `Flujo saliente` = resultado_Promethee_I$vflujos.sal,
                           check.names = FALSE)
crea_tabla_estilo(tabla_flujos, nombresfila = FALSE)
```

### Resultado

A continuación, vamos a mostrar una tabla que muestra que alternativas dominan a otras. La alternativa que a más alternativas domine y menos dominada sea será la preferida. Además se añade un grafo que ilustra el resultado de esta tabla, facilitando la interpretación e identificación de las mejores alternativas.

```{r}

crea_tabla_estilo_comparación(data.frame(resultado_Promethee_I$tablarelacionsupera,
                                         check.names = FALSE))
construir_grafo_animado(resultado_Promethee_I$tablarelacionsupera, plantilla = "circle")
```

Recordamos que alternativa correspondía a cada modelo

`{r} crea_tabla_estilo(tabla_alternativas_nombre, nombresfila = FALSE)`

## PROMETHEE II

### Índices

Para este método vamos a ultilizar dos funciones diferentes, una que imita la salida del software visual PROMETHEE y otra que nos da los resultados de forma similar al utilizado en el método anterior. En primer lugar vamos a mostrar el escenario que hemos planteado con la salida tipo visual PROMETHEE tras hacer uso de ambas funciones para guardar los resultados.

```{r}

resultado_Promethee_II <- multicriterio.metodo.promethee_ii_med(matriz_decisión, criterios_subcriterios, tabla_preferencia)
resultado_Promethee_II_Win <- multicriterio.metodo.promethee_windows(matriz_decisión, tabla_preferencia, criterios_subcriterios, c(rep("min",2),rep("max",6)))

tablas_resultado_Promethee_II_Win <- multicriterio.metodo.promethee_windows_kableExtra_html(resultado_Promethee_II_Win)

tablas_resultado_Promethee_II_Win$tabEscenario
```

<br>

Esta tabla nos muestra tres bloques, el primer bloque de preferencias nos muestra un resumen de los parámetros que hemos establecido en el enunciado. El segundo bloque, estadísticas, nos da un resumen descriptivo de las evaluaciones. Dichas evaluaciones se encuentran en el tercer bloque.

### Resultado

Ahora vamos a mostrar la tabla de flujos netos, que es la diferencia entre los flujos entrantes y salientes que veíamos en el resultado anterior. Vamos a mostrar dos tablas distintas que representan lo mismo, cada una para los resultados ofrecidos por las distintas funciones. Como para el desarrollo del problema con funciones de clase hemos empleado aquellas que normalizan los flujos, el resultado obtenido es el mismo, de no haberlas normalizado podríamos obtener valores distintos para los flujos.

#### Tabla resultado funciones_win
```{r}
tablas_resultado_Promethee_II_Win$tabAcciones
```

#### Tabla resultado funciones_clase

```{r}
tabla_flujos_netos <-  data.frame(Alternativa = names(ponderaciones_final),
                                  `Flujo neto` = resultado_Promethee_II$vflujos.netos,
                                   check.names = FALSE)

crea_tabla_estilo(tabla_flujos_netos, nombresfila = FALSE)
```

Además para el resultado, también añadimos un grafo que nos ayuda a identificar las dominancias entre alternativas junto a los flujos netos.

```{r}
construir_grafo_animado(resultado_Promethee_II$tablarelacionsupera, plantilla = "circle")
```

Recordamos que alternativa correspondía a cada modelo

`{r} crea_tabla_estilo(tabla_alternativas_nombre, nombresfila = FALSE)`

## Conclusión

Podemos comprobar que la mejor alternativa bajo los pesos establecidos para el problema y empleando este método es el modelo "`{r} names(ponderaciones_final)[1]`". Seguido del modelo "`{r} names(ponderaciones_final)[5]`" y como tercera opción el "`{r} names(ponderaciones_final)[3]`". En promethee I no hemos tenido el caso de que dos alternativas (o más) fueran incomparables por lo que esta conclusión es apta para ambos, PROMETHEE I y II. Se recomienda entonces al arquitecto adquirir el modelo "`{r} names(ponderaciones_final)[1]`".

# Método axiomático de Arrow y Raymond

## Planteamiento para Arrow y Raymond

Este método no emplea pesos, compara todas las alternativas entre ellas para cada criterio y hace una tabla que acumula cantidad de criterios en los que una alternativa (fila) supera a las demás (columnas).

Además se puede realizar un análisis de sensibilidad, multiplicando la primera alternativa (en este caso) por un valor $\alpha$ mayor o igual a uno que mejora los valores de esa alternativa progresivamente. De esta forma podemos observar como su variación afecta al orden final.

Vamos a hacer el análisis de sensibilidad a la vez que aplicamos el método y el resultado para el método será la primera iteración del análisis con $\alpha$ = 1, que no modifica la alternativa.

## Desarrollo

Vamos a mostrar la matriz de superaciones en las iteraciones primera y última del método, recordemos que este método va reduciendo las alternativas a medida que itera. Quedando en el último paso la alternativa preferida.

```{r}

intalpha <- seq(1,2,0.1)
sols <- vector("list", length(intalpha))
sols_pasos <- vector("list", length(intalpha))

for (i in 1:length(intalpha)) {
Mat_i <- matriz_decisión
Mat_i[4,] <- Mat_i[4,] * intalpha[i]
sol_ArrowRaymond_i <- multicriterio.metodoaxiomatico.ArrowRaymond(Mat_i)
sols[[i]] <- sol_ArrowRaymond_i$alternativasordenadas
sols_pasos[[i]] <- sol_ArrowRaymond_i$pasos
}
```

Aquí vemos la tabla para la primera iteración:

```{r}
data.frame(sols_pasos[[1]][[1]]$Mclasificacion,
           check.names = FALSE) |> crea_tabla_estilo_comparación()
```

<br>

Ahora mostramos la tabla de la última iteración

```{r}
data.frame(sols_pasos[[1]][[4]]$Mclasificacion,
           check.names = FALSE) |> crea_tabla_estilo_comparación()
```

En esta tabla ya se puede observar el resultado del método, pero vamos a visualizarla de más formas.

### Análisis de sensibilidad

Para el análisis de sensibilidad vamos a mostrar el gráfico que muestra la evolución de la cuarta alternativa según aumenta $\alpha$. Se ha escogido esta alternativa por ser la peor inicialmente.

```{r}

observar_posiciones <- function(valfas, alter, solu){
    posiciones = rep(NA,length(valfas))
    for (i in 1:length(valfas)) {
    #i = 1
        posiciones[i] = which(solu[[i]]==alter)
    }
return(posiciones)
}

lista_ArrowRaymond <-  lapply(names(ponderaciones_final), observar_posiciones, valfas=intalpha, solu=sols)

```

Recordemos que las primeras posiciones que se visualizan ($\alpha$ = 1) representan el resultado del método.

```{r}

dataframe_ArrowRaymon <- lista_ArrowRaymond |> 
  purrr::imap_dfr(~ tibble(
    alpha = intalpha,
    posicion = .x,
    alternativa = paste0("a", .y)
  ))


ggplot(dataframe_ArrowRaymon, aes(x = alpha, y = posicion, color = alternativa)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2) +
  scale_color_manual(values = c("#005682", "#C3625B", "#7FBFF5", "#F8A29E", "#111111")) +
  labs(
    title = "Evolución de posiciones por alternativa",
    x = expression(alpha),
    y = "Posición"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.title = element_blank(),
    legend.position = "top",
    plot.title = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank()
  )

```

En el gráfico podemos ver claramente como se ordenan las alternativas en este método, en cuanto a la sensibilidad podemos decir que las mejores opciones sostienen su posición frente a incrementos de hasta el 40% en la peor alternativa. Sin embargo, incrementos pequeños hacen que las alternativas en tercera y cuarta posición sean adelantadas rápidamente. Por ello, el resultado en nuestro caso es sensible a cambios en las evaluaciones de las alternativas o la inclusión de otras alternativas.

## Conclusiones

Este método nos indicaría que la mejor alternativa es el monitor "`{r} names(ponderaciones_final)[3]`" y la segunda mejor, el monitor, "`{r} names(ponderaciones_final)[1]`". Con este método recomendaríamos al arquitecto optar por la mejor alternativa, "`{r} names(ponderaciones_final)[3]`". Pero como veremos a continuación no lo consideraremos el mejor método para tomar la decisión.

:::

<div style="text-align: right;">
<a href="#cambioMétodo" class="btn-custom">Cambiar método multicriterio</a>
</div>

# Conclusión final

### Comparación de los métodos

Para comparar los métodos, en primer lugar se va a adjuntar una tabla resumen con los resultados obtenidos para cada método.

```{r}
data.frame(Método = c("AHP", "ELECTRE", "PROMETHEE", "Arrow y Raymond"),
           `Mejor alternativa` = c(rep(names(ponderaciones_final)[1], 3),
                                     names(ponderaciones_final)[3]),
           `Segunda alternativa` = c(names(ponderaciones_final)[5],
                                     names(ponderaciones_final)[3],
                                     names(ponderaciones_final)[5],
                                     names(ponderaciones_final)[1]),
            check.names = FALSE) |> crea_tabla_estilo(nombresfila = FALSE)

```

Así, podemos comprobar lo que se ha comentado a lo largo del desarrollo de los métodos, aquellos que nos dejan controlar mejor lo que se valora y como se valora dan un resultado más acorde a los pesos de los criterios y las valoraciones de las alternativas (AHP y PROMETHEE). Por otra parte los métodos axiomático de Arrow y Raymond junto al ELECTRE son más rígidos en este aspecto y cualquier diferencia entre las evaluaciones tiene un impacto final en su resultado. En el caso particular del método ELECTRE nos permite algo de holgura pero al ser post evaluación de los criterios solo nos habilita "quitar" dominancias. Por su parte, la ausencia de pesos en el Axiomático de Arrow y Raymond provoca que solo lo recomendemos para casos de igualdad de pesos entre los criterios, cuando cualquier diferencia entre ellos ya es significativa, o para apoyarnos en la comparación de las alternativas en bruto, antes de emplear otros métodos. 

Finalmente podemos destacar los métodos AHP y PROMETHEE como los más versátiles en casos como este, para comparar artículos con características medibles como vehículos, viviendas o productos tecnológicos entre otros. No se debe olvidar que una mayor flexibilidad también provoca que podamos manipularlo, para obtener resultados que, de forma subjetiva, nos hayan convencido más antes de iniciar el proceso de decisión. Por tanto apoyarnos en otros métodos más rígidos o ser lo más objetivo posible es indispensable.

### Decisión final

Viendo los resultados obtenidos para todos los métodos se va a optar por el modelo "`{r} names(ponderaciones_final)[1]`" dado que aparece como la alternativa dominante en tres de los cuatro métodos y en el único que no aparece como mejor alternativa, se mantiene como el segundo mejor.
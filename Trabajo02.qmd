---
title: "Adquisición de un monitor de PC mediante métodos multicriterio"
author: "Víctor Silva Nieves"
format: 
  html:
    toc: false
    number-sections: false
    code-fold: false
    embed-resources: true
    theme:
      - cosmo
      - estilo/tema.scss
    warning: false
lang: es
---

# Presentación del problema

El objetivo de este documento será elegir la mejor alternativa a la hora de adquirir un nuevo monitor de PC. Se van a considerar dos profesionales diferentes como interesados en esta adquisición, para observar como cambian las decisiones en función de las necesidades de cada uno. 

Se van a seleccionar 5 monitores diferentes, que tratan de representar una variedad de opciones en el mercado actual. Los criterios que se van a considerar son los siguientes:

* Precio (€)
* Tamaño (pulgadas)
* Frecuencia de actualización (Hz) o de refresco.
* Resolución (px)
* Consumo energético (W) en un instante.
* Densidad de píxeles (ppi)
* Brillo (nits)
* Contraste (en millones de colores M)

Y las alternativas las podemos ver en la siguiente tabla:
```{r}

# Carga de librerías necesarias
library(DiagrammeR)
library(ahp)

# Carga de funciones multicriterio
source("teoriadecision_funciones_multicriterio.R")
source("teoriadecision_funciones_multicriterio_diagram.R")
source("teoriadecision_funciones_multicriterio_utiles.R")

# Carga otras funciones
source("otras_funciones.R")
source("tablas_planteamiento_AHP.R")
source("animación_grafo.R")

```

```{r}
datos <- read.csv2("monitores.csv", header = FALSE, sep = ";")
colnames(datos) <- c("Modelo","Precio", "Tamaño", "Frecuencia", "Resolución", "Consumo", "Densidad", "Brillo", "Colores")
unidades <- c("€", "pulgadas", "Hz", "px", "W", "ppi", "nits", "M")

crea_tabla_estilo(datos, nombresfila = FALSE)
```

El primer interesado en tomar la decisión es un arquitecto que busca un monitor que le permita trabajar con planos y renderizados de alta calidad. El precio le preocupa en poca medida, pero quiere un monitor que ofrezca buena resolución y una buena representación de colores. Además, valora un tamaño grande para facilitar su trabajo.

El segundo interesado es un desarrollador que trabaja con R y Python. Considera el precio es un factor importante. Valora un gran tamaño de pantalla para poder tener varias ventanas abiertas y una buena frecuencia de actualización para evitar la fatiga visual. La resolución o los colores son menos importantes para él.

En cuanto al consumo ambos quieren que sea lo más bajo posible pero ninguno lo valora especialmente.

::: {.panel-tabset}

# Método AHP 

## Planteamiento para el método AHP

### Introducción

Para el método AHP, se va a dar una estructura jerárquica de criterios y subcriterios. Se van a considerar tres criterios: Coste, calidad de imagen y experiencia de usuario.

* El criterio coste, incluye los subcriterios: precio y consumo energético.

* El criterio calidad de imagen, incluye los subcriterios: resolución, densidad, brillo y colores.

* El criterio experiencia de usuario, incluye los subcriterios: tamaño y frecuencia de actualización.

Vemos a continuación un diagrama que representa esta jerarquía:

```{r}
DiagrammeR::grViz("
digraph {
    node [shape = rectangle, style = 'rounded,filled', fontname = 'Source Sans Pro', fontsize = '12']
    A [label = 'Elección de un monitor', fillcolor = '#C7645D']
    B [label = 'Coste', fillcolor = '#E2807A']
    C [label = 'Calidad de Imagen', fillcolor = '#E2807A']
    D [label = 'Experiencia de Usuario', fillcolor = '#E2807A']
    E [label = 'Precio', fillcolor = '#F8A29E']
    F [label = 'Consumo', fillcolor = '#F8A29E']
    G [label = 'Resolución', fillcolor = '#F8A29E']
    H [label = 'Densidad', fillcolor = '#F8A29E']
    I [label = 'Brillo', fillcolor = '#F8A29E']
    J [label = 'Colores', fillcolor = '#F8A29E']
    K [label = 'Tamaño', fillcolor = '#F8A29E']
    L [label = 'Frecuencia', fillcolor = '#F8A29E']
    edge[color = '#005A89', arrowsize = '0.5']
    A -> {B C D}
    B -> {E F}
    C -> {G H I J}
    D -> {K L}
}")
```

### Matrices de comparación por parejas

A continuación se establecen las siguientes matrices de comparación por parejas para los criterios, subcriterios y alternativas. Se ha realizado en un script anexo llamado "tablas_planteamiento_AHP.R" para una mejor legibilidad.

#### Nivel 1 - Criterios

`{r} tbahp0101`

#### Nivel 2 - Subcriterios:

##### Coste:
`{r} tbahp0201`
##### Calidad de Imagen:
`{r} tbahp0202`
##### Experiencia de Usuario: 
`{r} tbahp0203`

#### Nivel 3 - Alternativas:

##### Precio:
`{r} tbahp0301`
##### Consumo:
`{r} tbahp0302`
##### Resolución:
`{r} tbahp0303`
##### Densidad:
`{r} tbahp0304`
##### Brillo:
`{r} tbahp0305`
##### Colores:
`{r} tbahp0306`
##### Tamaño:
`{r} tbahp0307`
##### Frecuencia:
`{r} tbahp0308`

## AHP con R

### Introducción de las matrices en R

En primer lugar vamos a introducir las matrices de comparación por parejas para emplear las funciones de clase. Se ha utilizado además la función `multicriterio.metodoAHP.chequeo.matrizcomparaciones` para asegurar que las matrices son válidas.

```{r}

## CRITERIOS

matriz_criterios_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(1/7,1/5,3), numalternativas = 3, v.nombres.alternativas = c(
        "Coste", "Calidad de Imagen", "Experiencia de Usuario"))

## SUBCRITERIOS

#Coste
matriz_subcriterio_coste_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(5), numalternativas = 2, v.nombres.alternativas = c("Precio", "Consumo"))

#Calidad de imagen
matriz_subcriterio_calidad_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(2,7,5,5,3,1/3), numalternativas = 4, v.nombres.alternativas = c(
        "Resolución", "Densidad", "Brillo", "Colores"))

#Experiencia de usuario
matriz_subcriterio_experiencia_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(3), numalternativas = 2, v.nombres.alternativas = c("Tamaño", "Frecuencia"))

## ALTERNATIVAS
 
#Precio
matriz_alternativas_precio_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(1/7,1/2,1/9,1/5,5,1/4,3,1/7,1/4,5), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Consumo
matriz_alternativas_consumo_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(1/4,1/2,1/9,1/3,3,1/6,2,1/8,3,7), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Resolución
matriz_alternativas_resolucion_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(5,5,9,1,1,3,1/5,3,1/5,1/9), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Densidad
matriz_alternativas_densidad_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(3,5,7,1,3,5,1/3,3,1/5,1/7), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Brillo
matriz_alternativas_brillo_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(7,2,7,6,1/3,1,2,6,5,2), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Colores
matriz_alternativas_colores_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(7,1,7,1,1/7,1,1/7,7,1,1/7), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

#Tamaño
matriz_alternativas_tamaño_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(7,1,7,5,1/7,1,1/3,7,5,1/3), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

# Frecuencia
matriz_alternativas_frecuencia_ahp <- multicriterio.crea.matrizvaloraciones_mej(
    c(1/5,1/3,5,7,3,7,9,6,8,3), numalternativas = 5, v.nombres.alternativas = datos$Modelo)

```

```{r}
## Intento trabajar con listas para reducir el código

lista_matrices_parejas <- list(matriz_criterios_ahp,
                               matriz_subcriterio_coste_ahp,
                               matriz_subcriterio_calidad_ahp,
                               matriz_subcriterio_experiencia_ahp,
                               matriz_alternativas_precio_ahp,
                               matriz_alternativas_consumo_ahp,
                               matriz_alternativas_resolucion_ahp,
                               matriz_alternativas_densidad_ahp,
                               matriz_alternativas_brillo_ahp,
                               matriz_alternativas_colores_ahp,
                               matriz_alternativas_tamaño_ahp,
                               matriz_alternativas_frecuencia_ahp)

## Le ponemos nombres para facilitar su localización
nombres_matrices <- c("Criterios", "Coste", "Calidad", "Experiencia",
                                "Precio", "Consumo", "Resolución", "Densidad",
                                "Brillo", "Colores", "Tamaño", "Frecuencia")
names(lista_matrices_parejas) <- nombres_matrices

## Ahora a todas las matrices de esta lista le aplicamos la función de inconsistencia

lista_inconsistencias <- lapply(lista_matrices_parejas, multicriterio.metodoAHP.coef.inconsistencia)

## Ahora a todas las matrices de la lista de matrices por parejas le aplicamos la función para calcular pesos

lista_pesos <- lapply(lista_matrices_parejas, multicriterio.metodoAHP.variante2.mediageometrica)

```

### Inconsistencia

Se ha realizado una tabla que recoge el análisis de inconsistencia de todas las matrices empleadas en el método AHP. Además se incluye una columna que recoge la validación de la matriz para su uso en el método AHP.

```{r}
## Al usar el método con listas, la hemos calculado también para matrices 2x2 sin ser necesario. 
# Esta función, permite redondear RI de aquellos que queremos calcular y sustituye NaN por "-"
# para mostrarlo en la tabla.

convertir_vector_valores_listaNaN <- function (x) {
    if(is.nan(x$RI.coef.inconsistencia)){
        inter <- "-"
    } else {
        inter <- round(x$RI.coef.inconsistencia,4)
    }
    return(inter)
}
tabla_inconsistencia_ahp <- data.frame(
    Matriz = c(
        "Criterios",
        "Subcriterio Coste",
        "Subcriterio Calidad de Imagen",
        "Subcriterio Experiencia de Usuario",
        "Alternativa Precio",
        "Alternativa Consumo",
        "Alternativa Resolución",
        "Alternativa Densidad",
        "Alternativa Brillo",
        "Alternativa Colores",
        "Alternativa Tamaño",
        "Alternativa Frecuencia"
    ),
    `RI Coeficiente inconsistencia` = sapply(lista_inconsistencias, convertir_vector_valores_listaNaN),
    Estado = sapply(lista_inconsistencias, function(x) x$mensaje),
    `Matriz aceptable` = sapply(lista_matrices_parejas, multicriterio.metodoAHP.chequeo.matrizcomparaciones))

    crea_tabla_estilo(tabla_inconsistencia_ahp, nombresfila = FALSE)

```

```{r}
# Preparación matriz criterios*subcriterios

c11 <- lista_pesos$Criterios$valoraciones.ahp[1] * lista_pesos$Coste$valoraciones.ahp[1]
c12 <- lista_pesos$Criterios$valoraciones.ahp[1] * lista_pesos$Coste$valoraciones.ahp[2]
c21 <- lista_pesos$Criterios$valoraciones.ahp[2] * lista_pesos$Calidad$valoraciones.ahp[1]
c22 <- lista_pesos$Criterios$valoraciones.ahp[2] * lista_pesos$Calidad$valoraciones.ahp[2]
c23 <- lista_pesos$Criterios$valoraciones.ahp[2] * lista_pesos$Calidad$valoraciones.ahp[3]
c24 <- lista_pesos$Criterios$valoraciones.ahp[2] * lista_pesos$Calidad$valoraciones.ahp[4]
c31 <- lista_pesos$Criterios$valoraciones.ahp[3] * lista_pesos$Experiencia$valoraciones.ahp[1]
c32 <- lista_pesos$Criterios$valoraciones.ahp[3] * lista_pesos$Experiencia$valoraciones.ahp[2]

criterios_subcriterios <- c(c11,c12,c21,c22,c23,c24,c31,c32)
names(criterios_subcriterios) <- nombres_matrices[5:12]

mat_pesos_alternativas <- matrix(c(
                            sapply(lista_pesos[5:12],function(x) x$valoraciones.ahp)
                            ),
                            ncol = 5, nrow = 8, byrow = TRUE)

ponderaciones_final <- criterios_subcriterios %*% mat_pesos_alternativas
colnames(ponderaciones_final) <- datos$Modelo

ponderaciones_final

```

## AHP con paquete

En primer lugar tenemos que crear el archivo ahp que almacena el modelo necesario para este paquete.

```{r}
modelo_ahp <- ahp::Load("modelo_monitores.ahp")
modelo_ahp

#Paso 2. Calcular las prioridades
Calculate(modelo_ahp,pairwiseFun = )
print(modelo_ahp, priority = function(x) x$parent$priority["Total", x$name])

#Paso 3. Visualizar la jerarquía
Visualize(modelo_ahp)

#Paso 4. Analizar
Analyze(modelo_ahp,variable = "priority" ,sort="orig")
#Paso 4b. alternativo
Analyze(modelo_ahp)
#Paso 5. Analizar con Tabla Mejorada
aa = AnalyzeTable(modelo_ahp)
formattable::as.htmlwidget(aa)
#Paso 5b. alternativo
aa = AnalyzeTable(modelo_ahp,variable = "priority",sort = "orig")
formattable::as.htmlwidget(aa)

```

```{r}
#| eval: false
ahp::RunGUI()
```

Para los métodos siquientes se van a emplear los pesos que hemos calculado usando el método AHP, de forma que podamos comparar los distintos métodos y sus resultados. Los teníamos almacenados en el vector criterios_subcriterios.

```{r}
criterios_subcriterios
```

# Método ELECTRE

### Matriz de decisión

Se establece la matriz de decisión, tenemos que hacer negativos los valores que se van a minimizar.

```{r}

matriz_decisión <- multicriterio.crea.matrizdecision(
                    c(-505,-40,2160,139,450,1060,39.7,120,
                      -244,-35,1440,108,250,16.7,27,180,
                      -449,-39,1440,93,400,1070,40,155,
                      -108,-21,1080,81,250,16.7,27,100,
                      -290,-37,2160,139,270,1000,31.5,60
                    ), 
                    numalternativas = 5,
                    numcriterios = 8
)

matriz_decisión

```

### Establecemos los parámetros para el método

#### Pesos

Como se ha mencionado anteriormente, vamos a emplear los pesos que hemos obtenido tras emplear el método AHP para los criterios y subcriterios

# Mostrar en una tabla estos pesos

#### Test de concordancia

El test de concordancia requiere un valor alfa que al ser reducido permite que más alternativas dominen a otras. El valor de alfa inicial que vamos a tomar es 0.7.

#### Test de discordancia

Los valores para $d_i$ pueden condicionar el resultado, en nuestro caso tenemos pocas alternativas, de características y rangos de precio muy variadas. Que lo hacen muy sensible a estos valores.

* Brillo: Una diferencia mayor de 50 nits en el brillo será suficiente para no pasar el test de discordancia.
* Colores: Se considera que diferencias menores a 100 (millones de colores) son insuficientes para no pasar el test de discordancia.
* Tamaño de pantalla: Una diferencia mayor de 3" hará que no se supere el test de discordancia

A continuación se proponen otros posibles valores para ejemplos con mayor cantidad de alternativas o con modelos de una gama similar.

* Precio: 150€
* Consumo: 15W 
* Resolución: 720 px
* Densidad de píxeles: 40 ppi
* Frecuencia de refresco: 60 Hz 

Además se considera que estas cantidades deberían ser ajustadas e introducidas en el método acorde a los pesos y las magnitudes. Por ejemplo, si se hubiera dado mayor importancia al precio en los pesos podríamos introducirlo como elemento para no superar el test de discordancia.

Algunas de las cantidades propuestas, como la resolución, serían adecuadas para este problema. La no influencia en el resultado final ha desincentivado su inclusión.

### Primera iteración
```{r}

iteración1_ELECTRE <- multicriterio.metodoELECTRE_I(matriz_decisión, 
                                                    pesos.criterios = criterios_subcriterios,
                                                    nivel.concordancia.minimo.alpha = 0.7,
                                                    no.se.compensan = c(Inf,Inf,Inf,Inf,50,100,3,Inf),
                                                    que.alternativas = TRUE
)

iteración1_ELECTRE$nucleo_aprox
qgraph::qgraph(iteración1_ELECTRE$relacion.dominante)

construir_grafo_animado(iteración1_ELECTRE$relacion.dominante, plantilla = "spring")

test <- func_ELECTRE_Completo(iteración1_ELECTRE)

```

Vemos que para este valor de alfa, las mejores alternativas son a1 y a3. Y observando el grafo podríamos concluir que la siguiente mejor opción es a5.

Vamos a reducir el valor de alfa y nos vamos 

```{r}
iteración2_ELECTRE <- multicriterio.metodoELECTRE_I(matriz_decisión, 
                                                    pesos.criterios = criterios_subcriterios,
                                                    nivel.concordancia.minimo.alpha = 0.6,
                                                    no.se.compensan = c(Inf,Inf,Inf,Inf,50,100,3,Inf),
                                                    que.alternativas = c(1,3)
)

iteración2_ELECTRE$nucleo_aprox
qgraph::qgraph(iteración2_ELECTRE$relacion.dominante, color = "#F8A29E", edge.color = "#005682" , edge.width = 1)


posiciones <- qgraph::qgraph(iteración1_ELECTRE$relacion.dominante, layout = "spring")

animacion <- qgraph::qgraph.animate(iteración1_ELECTRE$relacion.dominante, color = "#F8A29E", edge.color = "#005682" , edge.width = 1, constraint = Inf,
growth = "order", sleep = 0, smooth = TRUE, plotGraphs = FALSE, progress = FALSE, initLayout = posiciones$layout)

img_list <- lapply(animacion, function(g) {
  tmpfile <- tempfile(fileext = ".png")
  png(tmpfile, width = 600, height = 600)
  plot(g)
  dev.off()
  magick::image_read(tmpfile)
})

gif <- magick::image_animate(magick::image_join(img_list), fps = 0.5)
gif
magick::image_write(gif, "animacion_electre.gif")

``` 

Vemos que para este valor de alfa, las mejores alternativas son a1 y a3. Y observando el grafo podríamos concluir que la siguiente mejor opción es a5.

Vamos a reducir el valor de alfa y las 

# Método PROMETHEE

## Tab

### Funciones de preferencia

Para cada criterio vamos a elegir una función de preferencia según la naturaleza de cada uno, tratando además que proporcionen mayor satisfacción a los requisitos del arquitecto. Recordemos los criterios:

* **Precio:** El precio no está entre los requisitos más importantes, pero queremos que tenga algo de indicencia en la decisión final, querríamos que para cantidades con diferencias pequeñas no exista preferencia alguna. Por ello vamos a tomar un valor de Q= 50€

* **Consumo:** El coste anual que supone una diferencia de 10W trabajando es de 2.4€; Cálculo: 10W = 0.01 kW, 6 horas al día todos los días, 0.01 kW x 6 x 365 = 21.90 kWh anuales. Con el precio medio actual 0.1090 €/kWh: 21.90 kWh x 0.1090 €/kWh = 2.3871€. Esto motiva que sigamos optemos por el Cuasi-Criterio. Con no preferencia en todas las diferencias menores que Q = 10W.

* **Resolución:** Aquí queremos que haya dominancia absoluta en aquellos valores que superen a otros por 720 px, de esta forma establecemos niveles bien diferenciados según la resolución. Preferencia lineal

* **Densidad:** Para la densidad de píxeles vamos a emplear el criterio usual, queremos que cualquier diferencia positiva resulte en preferencia absoluta. Si tuviéramos monitores con densidad de píxeles por encima de 150 elegiríamos un criterio que nos permitiera diferenciar que a partir de esa cantidad apenas existe diferencia.

* **Brillo:** Para el brillo vamos a optar por dar preferencia a monitores con más de 100 nits de diferencia. Preferencia lineal.

* **Colores:** En el caso de los colores vamos a tratar de diferenciar aquellos con 16.7 millones de colores de aquellos que tienen +1000 millones de colores. Así cuando la diferencia sea menor de 100 (M) diremos que no hay preferencia. Cuasi-criterio.

* **Tamaño:** En cuanto al tamaño, queremos que monitores de tamaños muy similares no tengan dominancia entre si y que cualquier salto de tamaño medio nos proporcione dominancia absoluta. Para ello P = 4" y Q = 2". Función elegida lineal con área de indiferencia.

* **Frecuencia:** La frecuencia de refresco sigue una escala particular, normalmente saltos de 30 Hz se hacen notar bastante hasta cierta cantidad de Hz que los saltos deben ser mayores para que se note. Como para el arquitecto es un factor secundario, vamos a tomar que diferencias menores a 20 Hz no supondrán preferencia de una alternativa sobre otra y que saltos de 59 Hz si harán que escojamos una alternativa con preferencia absoluta. Para los valores intermedios queremos un reparto suavizado, vamos a tomar S = 60 Hz


```{r}

tabla_preferencia <- matrix(c(2,50,0,0, 
                              2,10,0,0, 
                              3,0,720,0,
                              1,0,0,0,
                              3,0,100,0,
                              2,100,0,0,
                              5,2,4,0,
                              6,60,20,60),
                              ncol = 4, 
                              byrow = TRUE)
```

## PROMETHEE I


```{r}
resultado_Promethee_I <- multicriterio.metodo.promethee_i(matriz_decisión,
                                                        criterios_subcriterios,
                                                        tabla_preferencia)

resultado_Promethee_I$tabla.indices
resultado_Promethee_I$tablarelacionsupera
qgraph::qgraph(resultado_Promethee_I$tablarelacionsupera, color = "#F8A29E", edge.color = "#005682" , edge.width = 0.5)
```

### Medias

```{r}
resultado_Promethee_I_medias <- multicriterio.metodo.promethee_i_med(matriz_decisión, criterios_subcriterios, tabla_preferencia)

qgraph::qgraph(resultado_Promethee_I_medias$tablarelacionsupera)
```

## PROMETHEE II


```{r}

resultado_Promethee_II <- multicriterio.metodo.promethee_ii(matriz_decisión, criterios_subcriterios, tabla_preferencia)

resultado_Promethee_II$vflujos.netos

qgraph::qgraph(resultado_Promethee_II$tablarelacionsupera)

resultado_Promethee_II_Win <- multicriterio.metodo.promethee_windows(matriz_decisión, tabla_preferencia, criterios_subcriterios, c(rep("min",2),rep("max",6)))
    
source("teoriadecision_funciones_multicriterio_utiles.R")
test <- multicriterio.metodo.promethee_windows_kableExtra_html(resultado_Promethee_II_Win)
test$tabEscenario
test$tabAcciones
```

# Método axiomático de Arrow y Raymond

:::